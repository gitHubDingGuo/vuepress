# JVM


::: tip 提示
本篇内容主要总结JVM面试的一些内容 @dg
:::

[[toc]]

## 1. 什么是JVM内存结构？

![](http://blog-img.coolsen.cn/img/image-20210220111553294.png)

jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区；

* 程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；
* 虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；
* 本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；
* 堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；
* 方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；


#Java内存分配
Java的内存分为方法区、栈内存、堆内存、本地方法栈。
1、方法区(Method Area)
        方法区存着类的代码（装载信息）、常量池。
2、栈内存(Stacks)
        存放参数和局部变量，存储数据量小，访问速度快。
3、堆内存(Heap)
        存储对象，存储数据量大，访问速度慢。
4、本地方法栈内存(Native Method Stacks)
        存储与C语言交互的数据。
版权声明：本文为CSDN博主「better_zhang」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/better_zhang/article/details/121471484


#java中会存在内存泄漏吗,简述-下?
内存泄露的定义: 当某些对象不再被应用程序所使用,但是由于仍然被引用而导致垃圾收集器不能释放(Remove,移除)他们.
用白话来说就是:  该回收的内存没被回收 ,最后因为内存不够用而导致程序报错。
怎么防止内存泄露?
要防止内存泄露,下面是一些快速上手的实用技巧:
1. 当心集合类,比如 HashMap,ArrayList等,因为这是最容易发生内存泄露的地方.当集合对象被声明为static时,他们的生命周期一般和整个应用程序一样长。
2. 注意事件监听和回调.当注册的监听器不再使用以后,如果没有被注销,那么很可能会发生内存泄露.
3. "当一个类自己管理其内存空间时,程序员应该注意内存泄露." 常常是一个对象的成员变量需要被置为null 时仍然指向其他对象,

## 2. 什么是JVM内存模型？

**Java 内存模型**（下文简称 **JMM**）就是在底层处理器内存模型的基础上，定义自己的多线程语义。它明确指定了一组排序规则，来保证线程间的可见性。

这一组规则被称为 **Happens-Before**, JMM 规定，要想保证 B 操作能够看到 A 操作的结果（无论它们是否在同一个线程），那么 A 和 B 之间必须满足 **Happens-Before 关系**：

- **单线程规则**：一个线程中的每个动作都 happens-before 该线程中后续的每个动作
- **监视器锁定规则**：监听器的**解锁**动作 happens-before 后续对这个监听器的**锁定**动作
- **volatile 变量规则**：对 volatile 字段的写入动作 happens-before 后续对这个字段的每个读取动作
- **线程 start 规则**：线程 **start()** 方法的执行 happens-before 一个启动线程内的任意动作
- **线程 join 规则**：一个线程内的所有动作 happens-before 任意其他线程在该线程 **join()** 成功返回之前
- **传递性**：如果 A happens-before B, 且 B happens-before C, 那么 A happens-before C

怎么理解 happens-before 呢？如果按字面意思，比如第二个规则，线程（不管是不是同一个）的解锁动作发生在锁定之前？这明显不对。
happens-before 也是为了保证可见性，比如那个解锁和加锁的动作，
可以这样理解，线程1释放锁退出同步块，线程2加锁进入同步块，那么线程2就能看见线程1对共享对象修改的结果。

![](http://blog-img.coolsen.cn/img/image-20210329222941923.png)

Java 提供了几种语言结构，包括 *volatile*, *final* 和 *synchronized*, 它们旨在帮助程序员向**编译器**描述程序的并发要求，其中：

- **volatile** - 保证**可见性**和**有序性**
- **synchronized** - 保证**可见性**和**有序性**; 通过**管程（Monitor）\**保证一组动作的\**原子性**
- **final** - 通过禁止**在构造函数初始化**和**给 final 字段赋值**这两个动作的重排序，保证**可见性**（如果 **this 引用逃逸**就不好说可见性了）

编译器在遇到这些关键字时，会插入相应的内存屏障，保证语义的正确性。

有一点需要**注意**的是，**synchronized** **不保证**同步块内的代码禁止重排序，因为它通过锁保证同一时刻只有**一个线程**访问同步块（或临界区），也就是说同步块的代码只需满足 **as-if-serial** 语义 - 只要单线程的执行结果不改变，可以进行重排序。

所以说，Java 内存模型描述的是多线程对共享内存修改后彼此之间的可见性，另外，还确保正确同步的 Java 代码可以在不同体系结构的处理器上正确运行。

一、为什么要有内存屏障
内存屏障是为了解决因为cpu，高速缓存，主内存出现的时候，导致的可见性和重序性问题。

1、原理解释
因为计算机的运算任务需要CPU和内存相互配合共同完成，其中CPU负责逻辑计算，内存负责数据存储。但是在真正的实际开发中CPU是要与内存进行交互的，
但因为内存和CPU的计算速度是有差距的，因此为了提高CPU的利用效率，现代处理器结构都加入了一层读写速度尽可能接近CPU运算速度的高速缓存来作为内存与CPU之间的缓冲：
将运算需要使用的数据复制到缓存中，让CPU运算可以快速进行，计算结束后再将计算结果从缓存同步到主内存中，这样处理器就无须等待缓慢的内存读写了
。但在高速缓存解决CPU和内存之间速度的矛盾，但是在多CPU系统中也带来了新的问题：可见性问题和重排序问题。

二、Java层面的内存屏障
内存屏障（Memory Barrier）与内存栅栏（Memory Fence）是同一个概念，不同的叫法。而Java的层面 是应用volatile关键字去修饰变量，解决了编译器层面的可见性与重排序问题。

1、Java的屏障类型
Java中有四种类型：LoadLoad Barriers、StoreStore Barriers、LoadStore Barriers、 StoreLoad Barriers。从该四个类型中我们可以看到他们都是有Load和Store的不同排序组成。而这两个指令是来自硬件的内容。

1.1、Load指令和Store指令
Load指令(读屏障)：它将内存存储的数据拷贝到处理器的缓存中。

Store指令(写屏障):它主要实现让当前线程写入高速缓存中的最新数据更新写入到内存，让其他线程也可见。

1.2、LoadLoad Barriers
简单的理解就是当有两个Load,一个Load1一个Load2,Load1加载代码要从内存里面读取的数据读取完毕之后，Load2加载代码才能读取数据。

1.3、StoreStore Barriers
理解为当有两个Store,一个是Store1一个是Store2,Store1的写入操作已经把数据写入到内存里面，并且保证Store1的写入操作对其它处理器可见之后，才会对Store2存储代码进行写入操作执行。

1.4、LoadStore Barriers
理解为当有一个Load1和一个Store2,要先保证Load1加载代码要从内存里面读取的数据读取完毕之后，Store2存储代码才会进行写入操作。

1.5、StoreLoad Barriers
理解为当有一个Store1和Load2,要先保证Store1的写入操作已经把数据写入到内存里面，并且确认Store1的写入操作对其它处理器可见，Load2加载代码才从内存里面读取数据。
而且因StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为全能屏障，是目前大多数处理器所支持的，但是相对其他屏障，该屏障的开销相对昂贵的。

2、内存屏障在Volatile关键字里面的作用
在每个volatile写操作前插入StoreStore屏障，这样就能让其他线程修改A变量后，把修改的值对当前线程可见，在写操作后插入StoreLoad屏障，
这样就能让其他线程获取A变量的时候，能够获取到已经被当前线程修改的值

在每个volatile读操作前插入LoadLoad屏障，这样就能让当前线程获取A变量的时候，保证其他线程也都能获取到相同的值，这样所有的线程读取的数据就一样了，
在读操作后插入LoadStore屏障；这样就能让当前线程在其他线程修改A变量的值之前，获取到主内存里面A变量的的值。
————————————————
版权声明：本文为CSDN博主「君诀」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_48241564/article/details/122433626


https://blog.csdn.net/m0_46316970/article/details/122611293?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122611293-blog-122443822.pc_relevant_multi_platform_whitelistv4eslandingctr&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-122611293-blog-122443822.pc_relevant_multi_platform_whitelistv4eslandingctr&utm_relevant_index=2

## 3. heap 和stack 有什么区别？

**（1**）申请方式

stack:由系统自动分配。例如，声明在函数中一个局部变量 int b; 系统自动在栈中为 b 开辟空间

heap:需要程序员自己申请，并指明大小，在 c 中 malloc 函数，对于Java 需要手动 new Object()的形式开辟

**（2**）申请后系统的响应

stack：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。

heap：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。

**（3**）申请大小的限制

stack：栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS 下，栈的大小是 2M（默认值也取决于虚拟内存的大小），如果申请的空间超过栈的剩余空间时，将提示 overflow。因此，能从栈获得的空间较小。

heap：堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的， 自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见， 堆获得的空间比较灵活，也比较大。

**（4**）申请效率的比较

stack：由系统自动分配，速度较快。但程序员是无法控制的。

heap：由 new 分配的内存，一般速度比较慢，而且容易产生内存碎片,不过用起来最方便。

**（5**）heap和stack中的存储内容

stack：在函数调用时，第一个进栈的是主函数中后的下一条指令（函数调用语句的下一条可执行语句）的地址， 然后是函数的各个参数，在大多数的 C 编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。

当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。

heap：一般是在堆的头部用一个字节存放堆的大小。堆中的具体内容有程序员安排。

## 4. 什么情况下会发生栈内存溢出？

1、栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，
它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；
2、当线程请求的栈深度超过了虚拟机允许的最大深度时（无限递归），会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；
3、调整参数-xss去调整jvm栈的大小


#java8为什么移除永久代？
移除永久代原因：为融合HotSpot JVM与JRockit VM（新JVM技术）而做出的改变，因为JRockit没有永久代。
有了元空间就不再会出现永久代OOM问题了！

#Java堆的结构是什么样子的
jdk8(堆内存(年轻代[Eden区,Survivor区{s0区，s1区}],老年代)，元空间)
元数据空间并不在虚拟机中，而是使用本地内存。

## 5. 谈谈对 OOM 的认识？如何排查 OOM 的问题？

除了程序计数器，其他内存区域都有 OOM 的风险。
- 栈一般经常会发生 StackOverflowError，比如 32 位的 windows 系统单进程限制 2G 内存，无限创建线程就会发生栈的 OOM
- Java 8 常量池移到堆中，溢出会出 java.lang.OutOfMemoryError: Java heap space，设置最大元空间大小参数无效；
- 堆内存溢出，报错同上，这种比较好理解，GC 之后无法在堆中申请内存创建对象就会报错；
- 方法区 OOM，经常会遇到的是动态生成大量的类、jsp 等；
- 直接内存 OOM，涉及到 -XX:MaxDirectMemorySize 参数和 Unsafe 对象对内存的申请。

排查 OOM 的方法：

- 增加两个参数 -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/tmp/heapdump.hprof，当 OOM 发生时自动 dump 堆内存信息到指定目录；
- 同时 jstat 查看监控 JVM 的内存和 GC 情况，先观察问题大概出在什么区域；
- 使用 MAT 工具载入到 dump 文件，分析大对象的占用情况，比如 HashMap 做缓存未清理，时间长了就会内存溢出，可以把改为弱引用 。

OOM（Out of Memory）异常常见有以下几个原因：
1）老年代内存不足：java.lang.OutOfMemoryError:Javaheapspace
2）永久代内存不足：java.lang.OutOfMemoryError:PermGenspace
3）代码bug，占用内存无法及时回收。
OOM在这几个内存区都有可能出现，实际遇到OOM时，能根据异常信息定位到哪个区的内存溢出。
可以通过添加个参数-XX:+HeapDumpOnOutMemoryError，让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后分析。
————————————————
版权声明：本文为CSDN博主「智慧健康」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/wisdomhealth/article/details/110355611

## 6. 谈谈 JVM 中的常量池？

JVM常量池主要分为**Class文件常量池、运行时常量池，全局字符串常量池，以及基本类型包装类对象常量池**。

* **Class文件常量池**。class文件是一组以字节为单位的二进制数据流，在java代码的编译期间，我们编写的java文件就被编译为.class文件格式的二进制数据存放在磁盘中，其中就包括class文件常量池。
* **运行时常量池**：运行时常量池相对于class常量池一大特征就是具有动态性，java规范并不要求常量只能在运行时才产生，也就是说运行时常量池的内容并不全部来自class常量池，在运行时可以通过代码生成常量并将其放入运行时常量池中，这种特性被用的最多的就是String.intern()。
* **全局字符串常量池**：字符串常量池是JVM所维护的一个字符串实例的引用表，在HotSpot VM中，它是一个叫做StringTable的全局表。在字符串常量池中维护的是字符串实例的引用，底层C++实现就是一个Hashtable。这些被维护的引用所指的字符串实例，被称作”被驻留的字符串”或”interned string”或通常所说的”进入了字符串常量池的字符串”。 
* 基本类型包装类对象常量池：java中基本类型的包装类的大部分都实现了常量池技术，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外上面这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。


#垃圾回收机制是什么?
垃圾回收是一种自动的存储管理机制。 当一些被占用的内存不再需要时，就应该予以释放，以让出空间，这种存储资源管理，称为垃圾回收。
也就是说垃圾回收跟内存有关,那么都有哪些内存呢

#JVM内存
JVM将内存划分为五个区间.
JVM分为五大内存空间,其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生、随线程而灭，因此这几个区域的内存分配和回收都具备确定性，
就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟随着回收了。而Java堆区和方法区则不一样，这部分内存的分配和回收是动态的，正是垃圾收集器所需关注的部分。

#堆区的垃圾回收
什么是垃圾
如果一个对象已经没有任何一个地方引用它,它就是垃圾.

#怎么确定是垃圾
引用计数法
给对象添加一个引用计数器，每当有一个地方引用它时，计数器加一。反之每当一个引用失效时，计数器减一。当计数器为0时，则表示对象不被引用。
可达性分析
设立若干根对象(GC Root)，每个对象都是一个子节点，当一个对象找不到根时，就认为该对象不可达。

#触发条件
Minor GC触发机制
当年轻代满时就会触发Minor GC，这里的年轻代满指的是Eden代满，Survivor满不会引发GC。
FULL GC触发机制
老年代空间不足
方法区空间不足
通过Minor GC后进入老年代的平均大小大于老年代的可用内存。
由Eden区、From Survivor区向To Survivor区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小.
System.gc()方法的调用,系统建议执行Full GC，但是不必然执行.


## 7. 如何判断一个对象是否存活？

判断一个对象是否存活，分为两种算法1：引用计数法；2：可达性分析算法；

**引用计数法**：
给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收；
缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；

**可达性分析法**
设立若干根对象(GC Root)，每个对象都是一个子节点，当一个对象找不到根时，就认为该对象不可达。
从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：

* 虚拟机栈中引用的对象
* 方法区类静态属性引用的变量
* 方法区常量池引用的对象
* 本地方法栈JNI引用的对象

但一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；第一次标记：判断当前对象是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则进行第二次标记；第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃；如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；

## 8. 强引用、软引用、弱引用、虚引用是什么，有什么区别？
- 强引用，就是普通的对象引用关系，如 String s = new String("ConstXiong")
- 软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现
- 弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现
- 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。PhantomReference 实现

## 9. 被引用的对象就一定能存活吗？
 不一定，看 Reference 类型，弱引用在 GC 时会被回收，软引用在内存不足的时候，即 OOM 前会被回收，但如果没有在 Reference Chain 中的对象就一定会被回收。

#简述一下Java 垃圾回收机制?
在系统运行过程中，会产生一些无用的对象，这些对象占据着一
定的内存，如果不对这些对象清理回收无用对象的内存，可能会导致内存的耗尽，所以垃圾
回收机制回收的是内存。同时 GC 回收的是堆区和方法区的内存。
JVM 回收特点：(stop-the-world)当要进行垃圾回收时候，不管何种 GC 算法，除了垃圾回收
的线程之外其他任何线程都将停止运行。被中断的任务将会在垃圾回收完成后恢复进行。
GC 不同算法或是 GC 调优就是减少 stop-the-world 的时间。à(为何非要 stop-the-world)，就像是一个同学的聚会，地上有很多垃圾
，你去打扫，边打扫边丢垃圾怎么都不可能打扫干净的哈。当在垃圾回收时候不暂停所有的程序，在垃圾回收时候有 
new 一个新的对象 B，此时对象 A 是可达 B 的，但是没有来及标记就把 B 当成无用的对象给清理掉了，这就会导致程序的运行会出现错误。
https://blog.csdn.net/weixin_37943811/article/details/115128593

#垃圾回收器可以马.上回收内存吗?有什么办法主动通知虚拟机进行垃圾回收?
对于GC来说，当程序员创建对象时，GC就开始监控这个对象的地址、大小以及使用情况。通常，GC采用有向图的方式记录和管理堆(heap)中的所有对象。
通过这种方式确定哪些对象是"可达的"，哪些对象是"不可达的"。当GC确定一些对象为"不可达"时，GC就有责任回收这些内存空间。可以。
程序员可以手动执行System.gc()，通知GC运行，但是Java语言规范并不保证GC一定会执行。强制执行垃圾回收：System.gc()。Runtime.getRuntime().gc()
静态类：static的是属于类的，而不是属于对象的，相当于是全局的，不可能被回收
静态变量本身不会被回收，但是它所引用的对象应该是可以回收的。
gc只回收heap里的对象，对象都是一样的,只要没有对它的引用,就可以被回收(但是不一定被回收). 对象的回收和是否static没有什么关系!
如：static Vector pane = new Vector();  pane = null;  如果没有其它引用的话，原来pane指向的对象实例就会被回收。
Java程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java中的对象不再有"作用域"的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，
不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。
原文链接：https://blog.csdn.net/freekiteyu/article/details/8982727


#垃圾回收的优点和原理，并考虑2种回收机制
1.java语言最显著的特点就是引入了垃圾回收机制，它使java程序员在编写程序时不再考虑内存管理的问题。
2.由于有这个垃圾回收机制，java中的对象不再有“作用域”的概念，只有引用的对象才有“作用域”。
3.垃圾回收机制有效的防止了内存泄露，可以有效的使用可使用的内存。
4.垃圾回收器通常作为一个单独的低级别的线程运行，在不可预知的情况下对内存堆中已经死亡的或很长时间没有用过的对象进行清除和回收。
5.程序员不能实时的对某个对象或所有对象调用垃圾回收器进行垃圾回收。
6.垃圾回收有分代复制垃圾回收、标记垃圾回收、增量垃圾回收。
原文链接：https://blog.csdn.net/u011190556/article/details/11826103

# System.gc0和Runtime.gcO会做些什么?
System.gc()和runtime.gc()用于提示jvm进行垃圾回收。立即开始回收还是延迟回收回收取决于jvm
会触发full gc
调用 System.gc() 实际上等效于调用： Runtime.getRuntime().gc()

## 10. Java中的垃圾回收算法有哪些？
根搜索算法的基础上，现代虚拟机的实现当中，垃圾搜集的算法主要有三种，分别是标记- 清除算法、复制算法、标记-整理算法。
#标记-消除算法：**当堆中的有效内存被耗尽的时候，就会停止整个系统，就会调用标记- 消除算法，主要做两件事，1 就是标记，2 就是清除。然后让程序恢复。
  标记：遍历所有 GCroots 把可达的对象标记为存活的对象。
  清除：把未标记为存活的对象清楚掉。
缺点：
   就是效率相对比较低。会导致 stop-the-world 时间过长。
因为无用的对象内存不是连续的因此清理后的内存也不是连续的，(会产生内存碎片)因此
JVM 还要维持一个空闲列表，增加一笔开销，同时在以后内存使用时候，去查找可用的内存
这个效率也是很低的。
#复制算法：(这个算法一般适合在新生代 GC)，将原有的内存分为两块，每次只适用其中的一块，在垃圾回收的时候，将一块正在使用的内存中存活(上述根搜索的算法)的对象复制到另
一块没有使用的内存中，原来的那一块全部清除。与上述的标记-清除算法相比效率更高，
但是不太适合使用在对象存活较多的情况下(如老年代)。
**缺点：**每次对整个半区内存回收，因此效率比上面的要高点，同时在分配内存的时候不
需要考虑内存的碎片。按照顺序分配内存。简单高效。
但是最大的问题在于此算法在对象存活率非常低的时候使用，将可用内存分为两份，每次只
使用一份这样极大浪费了内存。
注意（重要）：现在的虚拟机使用复制算法来进行新生代的内存回收。因为在新生代中绝大
多数的对象都是“朝生夕亡”，所以不需要将整个内存分为两个部分，而是分为三个部分，一
块为 Eden 和两块较小的 Survivor 空间(比例->8:1:1)。每次使用 Eden 和其中的一块 Survivor，
垃圾回收时候将上述两块中存活的对象复制到另外一块 Survivor 上，同时清理上述 Eden 和
Survivor。所以每次新生代就可以使用 90%的内存。只有 10%的内存是浪费的。(不能保证每
次新生代都少于 10%的对象存活，当在垃圾回收复制时候如果一块 Survivor 不够时候，需要
老年代来分担，大对象直接进入老年代)
#标记-整理算法：(老年代 GC)在存活率较高的情况下，复制的算法效率相对比较低，同时还
要考虑存活率可能为 100%的极端情况，因此又不能把内存分为两部分的复制算法。
在上面标记-复制算法的基础之上，演变出了一个新的算法就是标记-整理算法。首先从
GCroots 开始标记所有可达的对象，标记为存活的对象。然后将存活的对象压缩到内存一端
按照内存地址的次序依次排列，然后末端内存地址之后的所有内存都清除。
**总结：**将标记存活的对象按照内存地址顺序排列到内存另一端，末端内存地址之后的内
存都会被清除。
**比较：**相比较于标记-清楚算法 (传统的)，该算法可以解决内存碎片问题同时还可以解
决复制算法部分内存不能利用的问题。但是标记-整理算法的效率也不是很高。
->上述算法都是根据根节点搜索算法来判断一个对象是不是需要回收，而支撑根节点搜索算
法能够正常工作理论依据就是语法中变量作用域的相关内容。
#三种算法比较：
**效率：**复制算法>标记-整理算法>标记-清除算法；
**内存整齐度：**复制算法=标记-整理算法>标记-清除算法
**内存利用率：**标记-整理算法=标记-清除算法>复制算法

java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法；
**标记清除法**：
第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
第二步：在遍历一遍，将所有标记的对象回收掉；
特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；

![](http://blog-img.coolsen.cn/img/image-20210220111918592.png)

**标记整理法**：
第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉；
特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；

![](http://blog-img.coolsen.cn/img/image-20210220111933505.png)

**复制算法**：
将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除；
特点：不会产生空间碎片；内存使用率极低；

**分代收集算法**：
根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，所以采用标记清理或者标记整理算法进行回收；

**对比**

![image-20210329224002527](http://blog-img.coolsen.cn/img/image-20210329224002527.png)

## 11. 有哪几种垃圾回收器，各自的优缺点是什么？

垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；
   收集器                串行         年代    算法      目标            适用场景                           其他
*Serial:           单线程收集器(串行)，新生代  复制算法， 响应速度优先，  单cpu环境的client模式               收集垃圾时，必须stop the world，使用复制算法。它的最大特点是在进行垃圾回收时，需要对所有正在执行的线程暂停（stop the world），对于有些应用是难以接受的，但是如果应用的实时性要求不是那么高，只要停顿的时间控制在N毫秒之内，大多数应用还是可以接受的，是client级别的默认GC方式。
*Serial Old:       单线程收集器(串行)  老年代  标记整理  响应速度优先    单cpu环境的client模式,cms后备预案
*ParNew:           多线程(并行)，     新生代  复制      响应速度优先    多cpu环境在server模式下与cms配合    也需要stop the world，复制算
*Parallel Scavenge:多线程(并行,并发)  新生代  复制      吞吐量优先     后台运算不需要太多交互的业务           目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；
*Parallel Old：    多线程(并行,并发)  老年代  标记整理   吞吐量优先     后台运算不需要太多交互的业务      
*CMS:             多线程(并发)       老年代  标记清除   响应速度优先   集中在网站或B/S系统服务端上的java应用   是一种以获得最短回收停顿时间为目标的收集器，标记清除算法，运作过程：初始标记，并发标记，重新标记，并发清除，收集结束会产生大量空间碎片；
*G1:              多线程(并发)       all  标记整理+复制 响应速度优先  面向服务端应用，将来替换CMS            标记整理算法实现，运作流程主要包括以下：初始标记，并发标记，最终标记，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；


# 串行( serial )收集器和吞吐量( throughput )收集器的区别是什么?
相应速度优先，一个吞吐量优先
https://blog.csdn.net/jhsword/article/details/105339097

**垃圾回收器间的配合使用图：**

![](http://blog-img.coolsen.cn/img/image-20210329224424220.png)

**各个垃圾回收器对比**：

![](http://blog-img.coolsen.cn/img/image-20210329230618579.png)

## 12. 详细说一下CMS的回收过程？CMS的问题是什么？

CMS(Concurrent Mark Sweep，并发标记清除) 收集器是以获取最短回收停顿时间为目标的收集器（追求低停顿），它在垃圾收集时使得用户线程和 GC 线程并发执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。

从名字就可以知道，CMS是基于“标记-清除”算法实现的。CMS 回收过程分为以下四步：

1. 初始标记 （CMS initial mark)：主要是标记 GC Root 开始的下级（注：仅下一级）对象，这个过程会 STW，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。

2. 并发标记 (CMS concurrent mark)：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。这个过程是多线程的，虽然耗时理论上会比较长，但是其它工作线程并不会阻塞，没有 STW。

3. 重新标记（CMS remark）：顾名思义，就是要再标记一次。为啥还要再标记一次？因为第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾。

4. 并发清除（CMS concurrent sweep）：清除阶段是清理删除掉标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发进行的。

**CMS 的问题：**

**1. 并发回收导致CPU资源紧张：**

在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程而导致应用程序变慢，降低程序总吞吐量。CMS默认启动的回收线程数是：（CPU核数 + 3）/ 4，当CPU核数不足四个时，CMS对用户程序的影响就可能变得很大。

**2. 无法清理浮动垃圾：**

在CMS的并发标记和并发清理阶段，用户线程还在继续运行，就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS无法在当次收集中处理掉它们，只好留到下一次垃圾收集时再清理掉。这一部分垃圾称为“浮动垃圾”。

**3. 并发失败（Concurrent Mode Failure）：**

由于在垃圾回收阶段用户线程还在并发运行，那就还需要预留足够的内存空间提供给用户线程使用，因此CMS不能像其他回收器那样等到老年代几乎完全被填满了再进行回收，必须预留一部分空间供并发回收时的程序运行使用。默认情况下，当老年代使用了 92% 的空间后就会触发 CMS 垃圾回收，这个值可以通过 -XX**:** CMSInitiatingOccupancyFraction 参数来设置。

这里会有一个风险：要是CMS运行期间预留的内存无法满足程序分配新对象的需要，就会出现一次“并发失败”（Concurrent Mode Failure），这时候虚拟机将不得不启动后备预案：Stop The World，临时启用 Serial Old 来重新进行老年代的垃圾回收，这样一来停顿时间就很长了。

**4.内存碎片问题：**

CMS是一款基于“标记-清除”算法实现的回收器，这意味着回收结束时会有内存碎片产生。内存碎片过多时，将会给大对象分配带来麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况。

为了解决这个问题，CMS收集器提供了一个 -XX**:**+UseCMSCompactAtFullCollection 开关参数（默认开启），用于在 Full GC 时开启内存碎片的合并整理过程，由于这个内存整理必须移动存活对象，是无法并发的，这样停顿时间就会变长。还有另外一个参数 -XX**:**CMSFullGCsBeforeCompaction，这个参数的作用是要求CMS在执行过若干次不整理空间的 Full GC 之后，下一次进入 Full GC 前会先进行碎片整理（默认值为0，表示每次进入 Full GC 时都进行碎片整理）。

## 13. 详细说一下G1的回收过程？

G1（Garbage First）回收器采用面向局部收集的设计思路和基于Region的内存布局形式，是一款主要面向服务端应用的垃圾回收器。G1设计初衷就是替换 CMS，成为一种全功能收集器。
G1 在JDK9 之后成为服务端模式下的默认垃圾回收器，取代了 Parallel Scavenge 加 Parallel Old 的默认组合，
而 CMS 被声明为不推荐使用的垃圾回收器。G1从整体来看是基于 标记-整理 算法实现的回收器，但从局部（两个Region之间）上看又是基于 标记-复制 算法实现的。

**G1 回收过程**，G1 回收器的运作过程大致可分为四个步骤：

1. 初始标记（会STW）：仅仅只是标记一下 GC Roots 能直接关联到的对象，并且修改TAMS指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。这个阶段需要停顿线程，但耗时很短，而且是借用进行Minor GC的时候同步完成的，所以G1收集器在这个阶段实际并没有额外的停顿。

2. 并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，这阶段耗时较长，但可与用户程序并发执行。当对象图扫描完成以后，还要重新处理在并发时有引用变动的对象。

3. 最终标记（会STW）：对用户线程做短暂的暂停，处理并发阶段结束后仍有引用变动的对象。

4. 清理阶段（会STW）：更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧Region的全部空间。这里的操作涉及存活对象的移动，必须暂停用户线程，由多条回收器线程并行完成的。

#    JVM的永久代中会发生垃圾回收么?
有些人认为方法区(如Hotspot虚拟机中的元空间或者永久代)是没有垃圾回收行为的，其实不然。

一般来说这个区域的回收效果比较令人难以满意，尤其是类型的卸载(类的卸载)，条件非常苛刻。但是这部分区域的回收有时又确实是有必要的。

方法区的垃圾回收主要回收两部分内容：常量池中废弃的常量和不在使用的类型(类)

Hotspot虚拟机堆常量池的回收策略是非常明确的，只要常量池中的常量没有被任何地方引用，就可以回收

但是判断一个类型是否属于“不在被使用的类”的条件就非常苛刻了。需要同时满足以下三个条件：

1、该类的所有实例都已经被回收，也就是堆中不存在该类及其任何派生子类的实例。

2、加载该类的类加载器已经被回收，这个条件通常是很难达到的。

3、该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
————————————————
版权声明：本文为CSDN博主「普通网友」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/m0_67401761/article/details/123830624


## 14.  JVM中一次完整的GC是什么样子的？

先描述一下Java堆内存划分。

在 Java 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )，新生代默认占总空间的 1/3，老年代默认占 2/3。
新生代有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。

新生代的垃圾回收（又称Minor GC）后只有少量对象存活，所以选用复制算法，只需要少量的复制成本就可以完成回收。

老年代的垃圾回收（又称Major GC）通常使用“标记-清理”或“标记-整理”算法。

![](http://blog-img.coolsen.cn/img/image-20210329225348086.png)

再描述它们之间转化流程：

* 对象优先在Eden分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

  * 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；

  - Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区；
  - 移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代。GC年龄的阀值可以通过参数 -XX:MaxTenuringThreshold 设置，默认为 15；
  - 动态对象年龄判定：Survivor 区相同年龄所有对象大小的总和 > (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%；
  - Survivor 区内存不足会发生担保分配，超过指定大小的对象可以直接进入老年代。

* 大对象直接进入老年代，大对象就是需要大量连续内存空间的对象（比如：字符串、数组），为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。

* 老年代满了而**无法容纳更多的对象**，Minor GC 之后通常就会进行Full GC，Full GC 清理整个内存堆 – **包括年轻代和老年代**。

## 15. Minor GC 和 Full GC 有什么不同呢？

Minor GC：于清理年轻代区域，当Eden区满了之后就会触发一次Minor GC，清理无用的对象，将有用的对象复制到S1和S2区中。
Major GC：用于清理年老代区域。
Full GC: 收集整个堆，包括 新生代，老年代，永久代(在 JDK 1.8及以后，永久代被移除，换为metaspace 元空间)等所有部分的模式。

**Minor GC触发条件：**当Eden区满时，触发Minor GC。

**Full GC触发条件**：

* 通过Minor GC后进入老年代的平均大小大于老年代的可用内存。如果发现统计数据说之前Minor GC的平均晋升大小比目前old gen剩余的空间大，则不会触发Minor GC而是转为触发full GC。
* 老年代空间不够分配新的内存（或永久代空间不足，但只是JDK1.7有的，这也是用元空间来取代永久代的原因，可以减少Full GC的频率，减少GC负担，提升其效率）。
* 由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小。
* 调用System.gc时，系统建议执行Full GC，但是不必然执行。

## 16. 介绍下空间分配担保原则？

如果YougGC时新生代有大量对象存活下来，而 survivor 区放不下了，这时必须转移到老年代中，但这时发现老年代也放不下这些对象了，那怎么处理呢？其实JVM有一个老年代空间分配担保机制来保证对象能够进入老年代。

在执行每次 YoungGC 之前，JVM会先检查老年代最大可用连续空间是否大于新生代所有对象的总大小。因为在极端情况下，可能新生代 YoungGC 后，所有对象都存活下来了，而 survivor 区又放不下，那可能所有对象都要进入老年代了。这个时候如果老年代的可用连续空间是大于新生代所有对象的总大小的，那就可以放心进行 YoungGC。但如果老年代的内存大小是小于新生代对象总大小的，那就有可能老年代空间不够放入新生代所有存活对象，这个时候JVM就会先检查 -XX:HandlePromotionFailure 参数是否允许担保失败，如果允许，就会判断老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次YoungGC，尽快这次YoungGC是有风险的。如果小于，或者 -XX:HandlePromotionFailure 参数不允许担保失败，这时就会进行一次 Full GC。

在允许担保失败并尝试进行YoungGC后，可能会出现三种情况：

- ① YoungGC后，存活对象小于survivor大小，此时存活对象进入survivor区中
- ② YoungGC后，存活对象大于survivor大小，但是小于老年大可用空间大小，此时直接进入老年代。
- ③ YoungGC后，存活对象大于survivor大小，也大于老年大可用空间大小，老年代也放不下这些对象了，此时就会发生“Handle Promotion Failure”，就触发了 Full GC。如果 Full GC后，老年代还是没有足够的空间，此时就会发生OOM内存溢出了。

通过下图来了解空间分配担保原则：

![](http://blog-img.coolsen.cn/img/image-20210329230240201.png)



## 17. 什么是类加载？类加载的过程？

虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象；

类的整个生命周期包括：加载（Loading）、验证（Verification）、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)和卸载(Unloading)7个阶段。其中准备、验证、解析3个部分统称为连接（Linking）。如图所示：

![image-20210329231258940](http://blog-img.coolsen.cn/img/image-20210329231258940.png)

加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（也称为动态绑定或晚期绑定）

类加载过程如下：

* 加载，加载分为三步：
  1、通过类的全限定性类名获取该类的二进制流；
  2、将该二进制流的静态存储结构转为方法区的运行时数据结构；
  3、在堆中为该类生成一个class对象；

* 验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；

* 准备：为class对象的静态变量分配内存，初始化其初始值；

* 解析：该阶段主要完成符号引用转化成直接引用；

* 初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；

## 18. 什么是类加载器，常见的类加载器有哪些？

类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；类加载器分为以下四种：

* 启动类加载器（BootStrapClassLoader）：用来加载java核心类库，无法被java程序直接引用；

* 扩展类加载器（Extension ClassLoader）：用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；

* 系统类加载器（AppClassLoader）：它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的；

* 自定义类加载器：由java语言实现，继承自ClassLoader；

![](http://blog-img.coolsen.cn/img/image-20210329231439914.png)

## 19. 什么是双亲委派模型？为什么需要双亲委派模型？

当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；

为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性。

补充：**那怎么打破双亲委派模型**？

自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法。

## 20. 列举一些你知道的打破双亲委派机制的例子，为什么要打破？

- JNDI 通过引入线程上下文类加载器，可以在 Thread.setContextClassLoader 方法设置，默认是应用程序类加载器，来加载 SPI 的代码。有了线程上下文类加载器，就可以完成父类加载器请求子类加载器完成类加载的行为。打破的原因，是为了 JNDI 服务的类加载器是启动器类加载，为了完成高级类加载器请求子类加载器（即上文中的线程上下文加载器）加载类。

- Tomcat，应用的类加载器优先自行加载应用目录下的 class，并不是先委派给父加载器，加载不了才委派给父加载器。

  tomcat之所以造了一堆自己的classloader，大致是出于下面三类目的：

  - 对于各个 `webapp`中的 `class`和 `lib`，需要相互隔离，不能出现一个应用中加载的类库会影响另一个应用的情况，而对于许多应用，需要有共享的lib以便不浪费资源。
  - 与 `jvm`一样的安全性问题。使用单独的 `classloader`去装载 `tomcat`自身的类库，以免其他恶意或无意的破坏；
  - 热部署。

  tomcat类加载器如下图：

  ![](http://blog-img.coolsen.cn/img/image-20210329231930719.png)

- OSGi，实现模块化热部署，为每个模块都自定义了类加载器，需要更换模块时，模块与类加载器一起更换。其类加载的过程中，有平级的类加载器加载行为。打破的原因是为了实现模块热替换。

- JDK 9，Extension ClassLoader 被 Platform ClassLoader 取代，当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。打破的原因，是为了添加模块化的特性。

## 21.说一下 JVM 调优的命令？

* jps：JVM Process Status Tool,显示指定系统内所有的HotSpot虚拟机进程。
* jstat：jstat(JVM statistics Monitoring)是用于监视虚拟机运行时状态信息的命令，它可以显示出虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据。
* jmap：jmap(JVM Memory Map)命令用于生成heap dump文件，如果不使用这个命令，还阔以使用-XX:+HeapDumpOnOutOfMemoryError参数来让虚拟机出现OOM的时候·自动生成dump文件。
  jmap不仅能生成dump文件，还阔以查询finalize执行队列、Java堆和永久代的详细信息，如当前使用率、当前使用的是哪种收集器等。
* jhat：jhat(JVM Heap Analysis Tool)命令是与jmap搭配使用，用来分析jmap生成的dump，jhat内置了一个微型的HTTP/HTML服务器，生成dump的分析结果后，可以在浏览器中查看。在此要注意，一般不会直接在服务器上进行分析，因为jhat是一个耗时并且耗费硬件资源的过程，一般把服务器生成的dump文件复制到本地或其他机器上进行分析。
* jstack：jstack用于生成java虚拟机当前时刻的线程快照。jstack来查看各个线程的调用堆栈，就可以知道没有响应的线程到底在后台做什么事情，或者等待什么资源。 如果java程序崩溃生成core文件，jstack工具可以用来获得core文件的java stack和native stack的信息，从而可以轻松地知道java程序是如何崩溃和在程序何处发生问题。
## Java对象创建过程
1. JVM遇到一条新建对象的指令时首先去检查这个指令的参数是否能在常量池中定义到一个类的符号引用。然后加载这个类（类加载过程在后边讲）
2. 为对象分配内存。一种办法“指针碰撞”、一种办法“空闲列表”，最终常用的办法“本地线程缓冲分配(TLAB)”
3. 将除对象头外的对象内存空间初始化为0
4. 对对象头进行必要设置

#讲讲你理解的性能评价及测试指标?
最常关注的几项性能指标有哪几个：QPS(TPS)、并发数、响应时间。
QPS（TPS）：每秒钟处理request/事务的数量。
并发用户数： 系统同时处理的request/事务的用户数量。
响应时间（Response Time，RT）： 可以理解为服务器处理响应的耗时，一般取平均响应时间。
下面将对QPS(TPS)、并发数、响应时间几项最主要的指标评估方法进行介绍，别急，且往下看。
————————————————
版权声明：本文为CSDN博主「小梧敲代码」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/xfw17397388089/article/details/119382483
https://blog.csdn.net/XiaoSen207/article/details/123228792

#常用的性能优化方式有哪些?
1. 复用优化
2. 计算优化 （1）并行执行 （2）变同步为异步 （3）惰性加载
3. 结果集优化
4. 资源冲突优化
5. 算法优化
6. 高效实现
7. JVM 优化
https://blog.csdn.net/agonie201218/article/details/122331825

#100个问题搞定Java虚拟机
https://blog.csdn.net/Shockang/article/details/116724631

#什么是GC调优?
https://blog.csdn.net/Shockang/article/details/116954931


## 巨人的肩膀

https://jishuin.proginn.com/p/763bfbd35094

https://www.javanav.com/val/93550f179edb4a77bbf4d35faa6d560c.html

https://juejin.cn/post/6844903941805703181

https://www.cnblogs.com/chiangchou/p/jvm-2.html

https://juejin.cn/post/6844903887866953735

https://segmentfault.com/a/1190000023182342